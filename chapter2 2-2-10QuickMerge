package Merge;
public class QuickMerge
{
public static Comparable[] quickSort(Comparable[]a,int low,int high)/**方便后面的降序*/
{
	int j=low,k=high;
	for(int i=low;i<=high-1;i++)/**n-1格排好序则最后一个元素就排好序了*/
	{
		Comparable sentry=a[i];/**设置哨兵；stl之前有讲过正确设置哨兵，但是现在不想搞*/
		{
			if(sentry.compareTo(a[j])>0)/**当从头开始寻找找到一个比哨兵小的数就停下*/
				{
				while(sentry.compareTo(a[k])>0))/**从尾部开始找大于哨兵的数*/
				
{
k++;
if(k<=j)
	return a;
}
Comparable temp=a[j];
a[j]=a[k];
a[k]=temp;
				}
			else
				if(sentry.compareTo(a[k])<0)
				{
					while(sentry.compareTo(a[j])<0)/**从尾部开始找大于哨兵的数*/					
	{
	j++;
	if(k<=j)
		return a;
	}
	Comparable temp=a[j];
	a[j]=a[k];
	a[k]=temp;
					}
				else
				{
					j++;
					k++;
				}
		
	}
}
	return a;
}
public static void merge(Comparable[]a,Comparable[]aux,int lo,int mid,int hi)
{
	int i=lo,j=mid+1;
	Comparable instance=a[0];//随便找的实例，方便下面调用compareTo;
	for(int k=lo;k<=hi;k++)
		aux[k]=a[k];
	quickSort(a,mid,hi);
	for(int m=mid;m<=hi;m++)
		aux[m]=a[m];
	for(int k=lo;k<=mid;k++)
		if(i>mid)a[k]=aux[j++];/**左边元素耗尽；*/
		else if(a[j].compareTo(a[i])<0)a[k]=aux[j++];
	/**怎么会less报错，大家不是有用Comparable interface吗，咋还不认呢;*/
		else aux[k]=a[i++];
}
}
